---
title: "Trabalho ME731"
author: "Gisele Amorim"
date: "2025-11-13"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
install.packages("HSAUR")
install.packages("heplots")
```

```{r}
library(tidyverse)
library(readxl)
library(xtable)
library(HSAUR)
library(heplots)
library(corrplot)
library(GGally)
library(lattice)
```

```{r}
setwd("C:/Users/gimor/OneDrive/Documentos/Faculdade/6S 2025/ME731/Trabalho")
```

#Análise Descritiva 

##Variáveis banco de dados

- Variáveis de identificação (IDs e códigos das espécies) [1]-[6]
- Informações do sítio arqueológico: onde cada crânio foi encontrado [7]-[14]
podem ser uteis para variações morfológicas ao longo do tempo ou local 
- "Skeletal part": indica se o crânio está completo ou se a mandíbula esta presente [15]
- Distâncias entre pontos anatômicos do crânio, variáveis numéricas contínuas - base ideal para PCA, analise fatorial, clusterig. [16]-[36] e [39]-[41]
- "Plis sourc", "Erster Hypoc": Provavelmente são características dentárias (PM2, PM4).
- Informações de coleta [42]- [44]


```{r}
dog_data <- read_xlsx('Van Giffen Measurement Data.xlsx')
colnames(dog_data)
```
O conjunto de dados possui 488 crânios, com 44 variáveis, incluindo medidas morfométricas, informações arqueológicas, coordenadas geográficas e identificadores das coleções.
```{r}
nrow(dog_data)
ncol(dog_data)
```
Separando a coluna com as medidas A-S(S') em duas outras onde A-S e A-S', onde os valores entre parenteses foram atribuidos a distância A-S' e o valor fora a A-S
```{r}
dados_van <- dog_data %>%
  mutate(
     `A-S'` = str_extract(`A-S (S')`, "(?<=\\().+?(?=\\))") %>%
      str_replace(",", ".") %>%        
      parse_number(),

    `A-S`  = str_replace(`A-S (S')`, "\\(.*?\\)", "") %>%  
      str_trim() %>%
      str_replace(",", ".") %>%         
      parse_number()
  ) %>%
  select(-`A-S (S')`) 
```


Analisando dados faltantes 
```{r}
na_percent <- sapply(dados_van, function(x) sum(is.na(x)) /length(x)) * 100
sort(na_percent, decreasing = TRUE)
```
```{r}
na_df <- data.frame(
  Variavel = names(na_percent),
  Percentual_NA = round(na_percent,2)
)

print(na_df)
```
As variáveis de maior porcentagem de NA, são principalmente dados administrativos como "BAI-ID", "RMO-ID", "Other-ID" ou características dentárias especificas que não estão relacionados diretamente as medidas morfolóficas dos cães. Assim, não possuem tanto efeito na análise de forma craniana. A medida A-S' tem a maior proporção de NA por isso não será utilizada nas análises para que não haja tanta perca de qualidade 
```{r}
table_na <- na_df %>% filter(Percentual_NA >= 40)
xtable(table_na)
table_na
```
As variáveis morfológicas principais com as medidas dos cães apresentam pouca proporção de valores ausentes no banco de dados, indicando que as variáveis mais valiosas para análise multivariada tem boa qualidade.
```{r}
na_df %>% filter(Percentual_NA >0, Percentual_NA < 20)
```
```{r}
ggplot(na_df, aes(x = reorder(Variavel, Percentual_NA), y = Percentual_NA)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  coord_flip() +
  labs(
    title = "Percentual de valores faltantes por variável",
    x = "Variável",
    y = "% de NA"
  ) +
  theme_bw() 
ggsave("histograma_NA.png")
```

Por meio da análise das variáveis e seus respectivos percentuais de NA, obtivemos que aquelas com percentual >40% são principalmente dados administrativos e não tão relevantes para as análise multivariada, por isso, retirei as mesmas para dar continuidade as análises.
- Variável "Erster Hypoc" relacionada à dentição, apresentou 65,57% de NAs, para a descrição será mantida, mas não a utilizaremos para as análises multivariadas
- Variavel "ba" unica variavel morfologica com alta proporção de valores faltantes

```{r}
data_van <- dados_van %>% select(-BAI_ID, -RMO_ID, -Other_ID, - `Year collected`, - `Alternate spelling`, - `A-S'`, -Comments, - `Erster Hypoc`, -ba )
head(data_van)
```

Imputação da média nos valores faltantes das variáveis numéricas mantidas para as análises 
```{r}
data <- data_van %>% 
  mutate(across(where(is.numeric), ~ replace_na(., mean(., na.rm = TRUE))))


head(data)
ncol(data)
colnames(data)

```

Análise das medidas morfológicas 
Estatísticas descritivas gerais 

```{r}
data_medidas <- data %>% select(where(is.numeric)) %>% select(-ID, - `Van Giffen ID_2`, - Latitude, - Longitude)

summary(data_medidas)
apply(data_medidas,2,sd,na.rm = TRUE)
```
```{r}
xbarra <- apply(data_medidas,2,mean, na.rm = TRUE)
S <- cov(data_medidas, use = "pairwise.complete.obs")
R <- cor(data_medidas, use = "pairwise.complete.obs")

xbarra
S
R
```
```{r}
corrplot(R, type = "lower", tl.cex = 0.7)
```
O gráfico de correlação mostra que quase todas as medidas craniométricas são fortemente correlacionadas entre si (predomínio de vermelho), indicando que elas aumentam juntas. Também é possível ver grupos de medidas que se correlacionam mais intensamente por estarem na mesma região anatômica. As medidas dentárias têm correlação menor, e praticamente não há correlações negativas.

```{r}
library(corrplot)

M <- cor(data_medidas, use = "pairwise.complete.obs")

corrplot(M,
         method = "color",
         type = "upper",
         tl.cex = 0.7,
         col = colorRampPalette(c("blue","lightblue","red"))(200))
```

Separando data_medidas, em medidas longitudinais, latitudinais e diagonais dos cães 
```{r}
medidas_comp <- data_medidas %>% select(`A-C`, `A-D`, `C-C'`, `C-D`, `D-mu`, `T-T'`, `E-E'`, `Eps-Eps’`, `A-S`)

medidas_larg <- data_medidas %>% select(`J-J'`, `H-H'`, `F-F'`, `L-L'`, `B-s`, `C-S`)
medidas_diag <- data_medidas %>% select(`S-Q'`, `D-Q'`, `D-S`, `DIII-IV`, `DII-III`)
```


Gráfico de boxplot referente as medidas morfológica dos cães, possivel verificar que as medidas morfométricas possuem diferentes escalas e níveis de variabilidade. Medidas longitudinais, como A-S, A-D, C-D e D-S, apresentam maior dispersão e presença de outliers, indicando alta variabilidade morfológica entre os indivíduos da amostra.

Já medidas transversais menores, como T–T', L–L', H–H' e E–E', apresentam menor dispersão. A presença frequente de outliers pode estar relacionada à heterogeneidade da amostra, diferenças reais entre indivíduos ou preservação óssea desigual.

```{r}
data_medidas %>%
  gather(variavel, valor) %>%
  ggplot(aes(x = variavel, y = valor)) +
  geom_boxplot(fill = "tomato") +
  coord_flip() +
  theme_bw()
```
```{r}
c <- medidas_comp %>%
  gather(variavel, valor) %>%
  ggplot(aes(x = variavel, y = valor)) +
  geom_boxplot(fill = "yellow") +
  labs(title = "Medidas de Comprimento") +
  coord_flip() +
  theme_minimal()
```



```{r}
l <- medidas_larg %>%
  gather(variavel, valor) %>%
  ggplot(aes(x = variavel, y = valor)) +
  geom_boxplot(fill = "lightblue") +
  labs(title = "Medidas de Largura") +
  coord_flip() +
  theme_minimal()
```

```{r}
d <- medidas_diag %>% 
  gather(variavel, valor) %>%
  ggplot(aes(x = variavel, y = valor)) +
  geom_boxplot(fill = "lightgreen") +
  labs(title = "Medidas Diagonal") +
  coord_flip() +
  theme_minimal()
```

```{r}
class(c)
class(l)
class(d)

```

```{r}

library(gridExtra)

grid.arrange(c, l, d, ncol = 3)
```

Análise de outliers
```{r}
library(MASS)

# Outliers por distância de Mahalanobis
m <- colMeans(data_medidas)
S <- cov(data_medidas)

dist_maha <- mahalanobis(data_medidas, center = m, cov = S)

# ponto de corte (qui-quadrado)
cut <- qchisq(0.999, df = ncol(data_medidas))

outliers <- which(dist_maha > cut)
length(outliers)
outliers

```

```{r}
plot(dist_maha, pch=20, main="Distância de Mahalanobis")
abline(h=cut, col="red")

```

```{r}
ggpairs(data = medidas_comp,
        )
```
 Gráfico heplots 
```{r}
library(heplots)

mod <- manova(as.matrix(data_medidas) ~ Period, data = data_period)
heplot(mod)

```


```{r}
period <- data[,c(5,6,7,8)]
print(period)
```
## Colunas de Data

As variáveis com informações de datas (Start Period, Start Range, End Period, End Range) apresentam alta proporção de valores faltantes e descrevem intervalos arqueológicos categóricos. Como não é apropriado imputar datas arqueológicas ausentes, optou-se por criar uma variável categórica simplificada (“Period_Broad”), baseada nos agrupamentos históricos apresentados no quadro cronológico (Iron Age, Roman Age, Medieval Period, Modern Era e Recent). Essa variável foi utilizada apenas para caracterização contextual da amostra, não sendo incluída nas análises multivariadas de medidas morfométricas.

```{r}

morf_vars <- c("C-C'", "C-D", "A-C", "A-D", "D-mu", "L-L'", "J-J'",
               "H-H'", "F-F'", "S-Q'", "D-Q'", "D-S", "DIII", "DIII-IV", 
               "DII-III", "T-T'", "E-E'", "Eps-Eps’", "C-S", "B-s", "A-S")
```

```{r}
data <- data %>% 
  rename(
    Start_Period = `Start Period`,
    Start_Range  = `Start Range`,
    End_Period   = `End Period`,
    End_Range    = `End Range`
  )
```


```{r}
data_period <- data %>% 
  mutate(
    Period = case_when(
      str_detect(Start_Period, "Iron") | str_detect(End_Period, "Iron") ~ "Iron Age",
      str_detect(Start_Period, "Roman") | str_detect(End_Period, "Roman") ~ "Roman Age",
      str_detect(Start_Period, "Medieval") | str_detect(End_Period, "Medieval") ~ "Medieval Period",
      str_detect(Start_Period, "Modern") | str_detect(End_Period, "Modern") ~ "Modern Era",
      str_detect(Start_Period, "Recent") | str_detect(End_Period, "Recent") ~ "Recent",
      TRUE ~ NA_character_
    )
  ) %>% 
  dplyr::select(-any_of(c("Start_Period","End_Period","Start_Range","End_Range")))

```

```{r}
data_period %>% group_by(Period) %>% summarise(quantidade = n())

```

```{r}
data_period %>% 
  group_by(Period) %>%
  summarise(across(all_of(morf_vars), ~mean(.x, na.rm = TRUE)))
```


```{r}
levels_ordem <- c("Iron Age", "Roman Age", "Medieval Period", "Modern Era")
data_period$Period <- factor(data_period$Period,
                          levels = levels_ordem[levels_ordem %in% unique(data_period$Period)]
)


data_period %>%
  filter(!is.na(Period), !is.na(`A-D`)) %>%
  ggplot(aes(x = Period, y = `A-D`)) +
  geom_boxplot(fill = "lightblue", alpha = 0.8) +
  labs(
    title = "Medida A-D por período",
    x = "Período Arqueológico",
    y = "Medida A-D"
  ) +
  theme_bw()

```

```{r}
data_period %>%
  filter(!is.na(Period), !is.na(`A-C`)) %>%
  ggplot(aes(x = Period, y = `A-C`)) +
  geom_boxplot(fill = "lightpink", alpha = 0.8) +
  labs(
    title = "Medida A-C por período",
    x = "Período Arqueológico",
    y = "Medida A-C"
  ) +
  theme_bw()

```

```{r}
data_period %>%
  filter(!is.na(Period), !is.na(`C-D`)) %>%
  ggplot(aes(x = Period, y = `C-D`)) +
  geom_boxplot(fill = "lightgreen", alpha = 0.8) +
  labs(
    title = "Medida C-D por período",
    x = "Período Arqueológico",
    y = "Medida C-D"
  ) +
  theme_bw()

```
Agrupar períodos históricos (cluster sobre médias)
Testando se os períodos possuem assinaturas morfológicas distintas, usando clustering das médias
```{r}
period_means <- data_period %>%
  drop_na(Period) %>%           
  group_by(Period) %>%
  summarise(across(all_of(morf_vars), mean, na.rm = TRUE)) %>%
  ungroup()                     

colnames(period_means)
period_means

```


```{r}
parallelplot(data_medidas)
```

```{r}
stars(data_medidas, main = "Gráfico de Estrelas - Medidas")
```





PCA - Analise de componentes principais por grupos de medidas 
Medidas de largura 

```{r}
X <- as.matrix(data_medidas)
n <- nrow(X)


medias <- colMeans(X)
desvios <- apply(X, 2, function(y) sqrt(sum((y - mean(y))^2) / (n - 1)))
X_centrado <- sweep(X, 2, medias, FUN = "-")
X_padronizado <- sweep(X_centrado, 2, desvios, FUN = "/")
```

Matriz de covariância dos dados padronizados
```{r}
CovMat <- (t(X_padronizado) %*% X_padronizado) / (n - 1)
```

Decomposição em Autovalores e Autovetores 
```{r}
decomposicao <- eigen(CovMat)
autovalores <- decomposicao$values
autovetores <- decomposicao$vectors


colnames(autovetores) <- paste0("PC", 1:ncol(autovetores))
rownames(autovetores) <- colnames(data_medidas)
```

Cálculo dos Scrores
```{r}
scores_pca <- X_padronizado %*% autovetores
```

Variância Explicada
```{r}
prop_variancia <- autovalores / sum(autovalores)
var_acumulada <- cumsum(prop_variancia)
```

Resultados
```{r}

result_table <- rbind(
  "Standard deviation"     = sqrt(autovalores),
  "Proportion of Variance" = round(prop_variancia, 5),
  "Cumulative Proportion"  = round(var_acumulada, 5)
)
colnames(result_table) <- paste0("PC", 1:ncol(result_table))

print("Importância das componentes:")
print(result_table[, 1:5]) 

print("Primeiros Loadings (Autovetores):")
print(head(autovetores[, 1:4]))

print("Primeiros Scores:")
print(head(scores_pca[, 1:4]))
```

```{r}
dados_pca <- data_period %>%
  dplyr::select(all_of(morf_vars), Period) %>%
  drop_na()

medidas <- dados_pca %>%  dplyr::select(all_of(morf_vars))
period <- dados_pca %>%  dplyr::select(Period)

pca <- prcomp(medidas, scale. = TRUE)
summary(pca)
plot(pca)
biplot(pca)
```

PCA - medidas de comprimento 
Não foram consideradas nas análises 
```{r}
pca_comp <- prcomp(medidas_comp, scale = FALSE)
summary(pca_comp)
plot(pca_comp)
biplot(pca_comp)
```
PCA - medidas de largura 
```{r}
pca_larg <- prcomp(medidas_larg, scale = FALSE)
summary(pca_larg)
plot(pca_larg)
biplot(pca_larg)
```

```{r}
pca_diag <- prcomp(medidas_diag, scale = FALSE)
summary(pca_diag)
plot(pca_diag)
biplot(pca_diag)
```
```{r}
scores_pca <- as.data.frame(pca$x)
scores_pca$ID <- rownames(scores_pca)
names(scores_pca)
```



## Análise de Variânica Multivariada (MANOVA)

```{r}
Y <- as.matrix(scores_pca[, c("PC1", "PC2")])  
grupo <- as.factor(data_period$Period)
```

Estatísticas 
```{r}
n <- nrow(Y)          
p <- ncol(Y)          
g <- nlevels(grupo)   
n_grupos <- table(grupo) 
niveis_grupo <- levels(grupo)
```

Médias globais e por grupo 
```{r}
media_global <- colMeans(Y)  

medias_grupo <- matrix(NA, nrow = g, ncol = p)
rownames(medias_grupo) <- niveis_grupo
colnames(medias_grupo) <- colnames(Y)

for (k in 1:g) {
  medias_grupo[k, ] <- colMeans(Y[grupo == niveis_grupo[k], , drop = FALSE])
}
```

Matrizes de Soma de Quadrados e Produtos
```{r}
#H: SQP entre grupos 
H <- matrix(0, nrow = p, ncol = p)
for (k in 1:g) {
  desvio_media <- matrix(medias_grupo[k, ] - media_global, ncol = 1)
  H <- H + n_grupos[k] * (desvio_media %*% t(desvio_media))
}

# E: SQP dentro dos grupos 
E <- matrix(0, nrow = p, ncol = p)
for (k in 1:g) {
  Y_grupo <- Y[grupo == niveis_grupo[k], , drop = FALSE]  # Dados do grupo k
  desvio_grupo <- sweep(Y_grupo, 2, medias_grupo[k, ], FUN = "-")  # Centralizar
  E <- E + t(desvio_grupo) %*% desvio_grupo  # Acumular
}
```

Autovalores da Matriz E_inv * H
```{r}
lambda <- 1e-6
E_inv <- solve(E + lambda * diag(p))

```

Estatísticas multivariadas e p-valores
```{r}
# Graus de liberdade
df_entre <- g - 1  
df_dentro <- n - g
```

Wilks' Lambda 
```{r}
wilks <- prod(1 / (1 + autovalores))  


F_wilks <- ((1 - sqrt(wilks)) / sqrt(wilks)) * ((df_dentro - p + 1) / p)
df1_wilks <- 2 * p
df2_wilks <- 2 * (df_dentro - p + 1)
p_wilks <- pf(F_wilks, df1 = df1_wilks, df2 = df2_wilks, lower.tail = FALSE)
```

Resultados MANOVA
```{r}
cat("MANOVA para PC1 e PC2 ~ Grupo\n")
cat("Número de observações:", n, "\n")
cat("Grupos:", g, "(", paste(niveis_grupo, collapse = ", "), ")\n\n")

cat("Wilks' Lambda:    ", round(wilks, 5), "\n")
cat("F aproximado:     ", round(F_wilks, 3), "\n")
cat("df1 =", df1_wilks, ", df2 =", df2_wilks, "\n")
cat("p-valor:          ", signif(p_wilks, 4), "\n\n")
```

K-means Clustering
```{r}
Y <- as.matrix(scores_pca[, c("PC1", "PC2")])  
n <- nrow(Y)
p <- ncol(Y)
k <- 3
set.seed(123)
```

escolhendo aleatoriamente k pontos como centróides
```{r}
centroids <- Y[sample(1:n, k), , drop = FALSE]  

```

```{r}
max_iter <- 100
cluster <- rep(0, n)  
for (iter in 1:max_iter) {
  

  dist_matrix <- as.matrix(dist(rbind(centroids, Y)))[1:k, (k+1):(k+n)]
  cluster_new <- apply(dist_matrix, 2, which.min)
  

  if (all(cluster_new == cluster)) {
    cat("Convergiu na iteração", iter, "\n")
    break
  }
  cluster <- cluster_new
  
  
  for (j in 1:k) {
    if (sum(cluster == j) > 0) {
      centroids[j, ] <- colMeans(Y[cluster == j, , drop = FALSE])
    }
  }
}

```
```{r}
library(ggplot2)
ggplot(as.data.frame(Y), aes(x = PC1, y = PC2, color = factor(cluster))) +
  geom_point(size = 3) +
  geom_point(data = as.data.frame(centroids), 
             aes(x = PC1, y = PC2), 
             color = "black", size = 5, shape = 8) +
  labs(color = "Cluster") +
  theme_minimal()

```


Regressão simples do PC1 por período
```{r}
pc1 <- pca$x[,1]

anova(lm(pc1 ~ data_period$Period))

```



Análise das variáveis latitude/longitude 
```{r}
ggplot(data_period, aes(x = Longitude, y = Latitude)) +
    geom_point(alpha = 0.6) +
    coord_equal() +
    labs(title = "Localização dos sítios arqueológicos")

```



--- outras tentativas utilizadas porém não discutidas e mais exploradas no relatório 

Clustering Multivariado (k-menans, hierarchical)
- hierárquico
```{r}
dist_m <- dist(scale(data_medidas))
hc <- hclust(dist_m, method = "ward.D2")
plot(hc)
rect.hclust(hc, k = 3, border = "red")

```

Associando clusters aos períodos
```{r}
clusters <- cutree(hc, k = 3)
table(clusters, data_period$Period)

```
```{r}
colnames(data_period)
```


Procrustes analysis
```{r}
library(vegan)

group_means <- data_period %>% 
  group_by(Period) %>%
  summarise(across(all_of(morf_vars), mean))

proc <- procrustes(group_means[1:4, -1],
                   group_means[1:4, -1], # comparação entre subconjuntos
                   scale = TRUE)

summary(proc)
plot(proc)

```

```{r}
# PCA
pca <- prcomp(data_medidas, scale. = TRUE)

# Scores
scores_pca <- as.data.frame(pca$x)
scores_pca$ID <- rownames(scores_pca)

# Duas primeiras componentes
pc12 <- scores_pca[, c("PC1", "PC2")]

# Defina o número de clusters manualmente
k <- 2   # escolha 2, 3 ou outro

# Checar se k é válido
if (k < 1 | k > nrow(pc12)) stop("Valor inválido de k")

# K-means
set.seed(123)
kmeans_res <- kmeans(pc12, centers = k)

scores_pca$cluster <- factor(kmeans_res$cluster)

library(ggplot2)
ggplot(scores_pca, aes(PC1, PC2, color = cluster)) +
  geom_point(size = 3) +
  theme_minimal() +
  labs(title = "K-means aplicado às duas primeiras componentes principais")

```

